---
import BaseLayout from '../../layouts/BaseLayout.astro';

export async function getStaticPaths() {
  return [
    { params: { locale: 'pt-br' } },
    { params: { locale: 'en-us' } },
  ];
}
---
<BaseLayout pageName="Portfolio">
    <canvas slot="main" id="canvas" class="w-full h-full"></canvas>
</BaseLayout>

<script>
import * as THREE from 'three';
import { OBJLoader } from 'three/examples/jsm/loaders/OBJLoader.js';
import { Main } from '../../common/scene/main';
import { Wall } from '../../common/scene/wall';
import { AnimationSystem } from '../../common/animation/animation-system';
import * as Tasks from '../../common/animation/animation-tasks';
import { AudioAPI } from '../../common/audio/audio-API';
import { AnimationAPI } from '../../common/animation/animation-API';

const main = new Main();
const loader = new OBJLoader();

/* =========================
   GRUPOS SEMÂNTICOS
========================= */
const groups = {
    furnitures: [] as THREE.Group[],
    walls: [] as THREE.Group[],
    floor: [] as THREE.Group[],
    ceiling: [] as THREE.Group[],
};

const hideable: Wall[] = [];

/* =========================
   CARREGAMENTO
========================= */
const furnitureModels = ['table', 'sofa'];

for (const model of furnitureModels) {
    const group = await loader.loadAsync(`/model/obj/${model}.obj`);
    group.children.forEach(c => {
        c.castShadow = true;
        c.receiveShadow = true;
    });
    main.scene.add(group);
    groups.furnitures.push(group);
}

const wallModels = [
    { name: 'floor',   normal: new THREE.Vector3( 0,  1,  0) },
    { name: 'wall_a',  normal: new THREE.Vector3( 1,  0,  0) },
    { name: 'wall_b',  normal: new THREE.Vector3( 0,  0,  1) },
    { name: 'wall_c',  normal: new THREE.Vector3(-1,  0,  0) },
    { name: 'wall_d',  normal: new THREE.Vector3( 0,  0, -1) },
    { name: 'ceiling', normal: new THREE.Vector3( 0, -1,  0) },
];

for (const model of wallModels) {
    const group = await loader.loadAsync(`/model/obj/${model.name}.obj`);
    main.scene.add(group);

    if (model.name === 'floor') {
        groups.floor.push(group);
    } else if (model.name === 'ceiling') {
        groups.ceiling.push(group);
    } else {
        groups.walls.push(group);
    }

    hideable.push(new Wall(model.normal, group.children[0] as THREE.Mesh));
}

/* =========================
   CÂMERA / LUZ
========================= */
main.light.position.set(0, 2, -3);
main.light.lookAt(0, 0, 0);

main.camera.position.set(5, 5, 5);
main.camera.lookAt(0, 1.25, 0);
main.controls.target.y = 1.25;

/* =========================
   ESTADO INICIAL
========================= */
const start = new THREE.Vector3(0, 3, 0);
const target = new THREE.Vector3(0, 0, 0);

Object.values(groups).flat().forEach(object => {
    object.visible = false;
    object.position.copy(start);
    object.children.forEach(child => {
        const mat = (child as THREE.Mesh).material as THREE.Material;
        mat.transparent = true;
        mat.opacity = 0;
    });
});

/* =========================
   UTILITÁRIOS
========================= */
const delay = (ms: number) => new Promise(r => setTimeout(r, ms));
const easeOut = (t: number) => 1 - Math.pow(1 - t, 3);

window.addEventListener(AnimationAPI.FINISH, () => {
    window.dispatchEvent(
        new CustomEvent("audio:play", {
            detail: { audio: AudioAPI.PLACED }
        })
    );
})
async function animateGroup(
    objects: THREE.Group[],
    duration: number,
    itemDelay: number = 0
) {
    await Promise.all(
        objects.map(async (object, index) => {
            if (itemDelay > 0) {
                await delay(index * itemDelay);
            }

            object.visible = true;

            const move = new Tasks.MoveTask(
                object,
                start,
                target,
                duration,
                easeOut
            );

            const fade = new Tasks.FadeTask(
                object,
                0,
                1,
                duration,
                easeOut
            );

            return AnimationSystem.run(
                new Tasks.ParallelTask([move, fade])
            )
        })
    );
}

/* =========================
   SEQUÊNCIA DE ANIMAÇÃO
========================= */
await delay(500);

await animateGroup(groups.floor, 600, 0)
await animateGroup(groups.furnitures, 1200, 150);
await animateGroup(groups.walls, 800, 500);
await animateGroup(groups.ceiling, 1000, 500);

/* =========================
   WALL CULLING DINÂMICO
========================= */
window.addEventListener('mousemove', () => {
    const direction = new THREE.Vector3();
    main.camera.getWorldDirection(direction);

    hideable.forEach(wall => {
        wall.mesh.visible = wall.normal.dot(direction) <= 0.5;
    });
});
</script>
